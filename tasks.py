from invoke import task
from pathlib import Path
from minchin.text import subtitle, title

REQUIREMENT_FILES = [
    "build",
    "dev",
]

ALL_REQUIREMENT_FILE = "all"

REQUIREMENTS_PATH = [
    ".requirements",
]

p = Path.cwd()
deploy_path = p / "output"
publish_path = p / "output"

@task
def update(ctx, verbose=False):
    """
    Update python requirements files to latest versions.

    Also, rebuilds "all.in" requirement file.
    """
    title("Update python requirements files to latest versions")

    base_path = Path(".")
    for folder in REQUIREMENTS_PATH:
        base_path = base_path / folder
    print(f'** base path: "{base_path}"')

    all_requirements = base_path.resolve() / f"{ALL_REQUIREMENT_FILE}.in"
    # make sure file already exists
    all_requirements.touch()
    all_requirements.write_text(
        "# ** This file is automatically generated. **\n"
        "# Do not edit by hand\n"
        "\n"
    )
    with all_requirements.open("a") as all_requirements_file:
        for requirement in REQUIREMENT_FILES:
            print()
            subtitle(f"** {requirement} **")
            print()
            ctx.run(f"pip-compile {base_path / requirement}.in", hide=not verbose)
            print(f"-r {requirement}.in", file=all_requirements_file)

    print()
    subtitle(f"** {all_requirements} **")
    print()
    ctx.run(f"pip-compile {base_path / ALL_REQUIREMENT_FILE}.in", hide=not verbose)

@task
def upgrade(ctx, requirement_file="all", build=False, dev=False, verbose=False):
    """
    Upgrade python requirements to version specified in requirements files.
    """

    title("Upgrade python requirements to version specified in requirements files")

    if build is True:
        requirement_file = "build"
    elif dev is True:
        requirement_file = "dev"

    base_path = Path(".")
    for folder in REQUIREMENTS_PATH:
        base_path = base_path / folder
    requirement_file = base_path / f"{requirement_file}.txt"
    print(f"** requirement file: {requirement_file}")

    ctx.run(f"pip-sync {requirement_file.resolve()}", hide=not verbose)


@task
def build(ctx, publish=False, carefully=False):
    """Build a local version of the blog."""

    config = "pelicanconf.py"
    if publish:
        config = "publishconf.py"

    if carefully:
        carefully_cli = " --fatal=warnings"
    else:
        carefully_cli = ""
    ctx.run("pelican -s {}{}".format(config, carefully_cli))

@task
def build_debug(ctx):
    """Use debug output to build a local version of the blog."""
    ctx.run("pelican -s pelicanconf.py --debug")

@task
def serve(ctx):
    """Serve the local blog output on port 8000."""
    ctx.run("cd {} && start python -m http.server".format(deploy_path))


@task
def serve_on(ctx, port):
    """Serve the local blog output on a port of your choosing."""
    ctx.run("cd {} && start python -m http.server {}".format(deploy_path, port))
